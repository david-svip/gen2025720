<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>直升机山地飞行模拟器</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }

    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }

    #camera-toggle {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="info">
    <div>高度: <span id="altitude">0</span>m</div>
    <div>速度: <span id="speed">0</span>km/h</div>
    <div>上升率: <span id="vertical-speed">0</span>m/s</div>
    <div>旋翼转速: <span id="rotor-rpm">0</span>RPM</div>
  </div>
  <div id="controls">
    <div>W/S: 俯仰(前/后)</div>
    <div>A/D: 滚转(左/右)</div>
    <div>Q/E: 上升/下降</div>
    <div>↑/↓: 总距(升力)</div>
    <div>←/→: 偏航(左/右)</div>
    <div>R: 重置位置</div>
  </div>
  <div id="camera-toggle">切换视角</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
  <script>
    // 场景设置
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    // 相机设置
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.position.set(0, 10, 0);

    // 驾驶舱相机
    const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    let currentCamera = camera;
    let isCockpitView = false;

    // 渲染器设置
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 光照
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // 创建直升机
    function createHelicopter() {
      const helicopter = new THREE.Group();
      // 机身
      const bodyGeometry = new THREE.CylinderGeometry(1, 0.5, 3, 8);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.rotation.z = Math.PI / 2;
      helicopter.add(body);

      // 尾梁
      const tailGeometry = new THREE.CylinderGeometry(0.2, 0.1, 4, 8);
      const tailMaterial = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.set(-2, 0, 0);
      tail.rotation.z = Math.PI / 2;
      helicopter.add(tail);

      // 主旋翼轴
      const rotorAxisGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
      const rotorAxisMaterial = new THREE.MeshPhongMaterial({ color: 0x696969 });
      const rotorAxis = new THREE.Mesh(rotorAxisGeometry, rotorAxisMaterial);
      rotorAxis.position.set(0, 0.5, 0);
      helicopter.add(rotorAxis);

      // 主旋翼 (旋转部分)
      const rotorGroup = new THREE.Group();
      body.rotation.z = Math.PI / 2;

      // 旋翼叶片
      const bladeGeometry = new THREE.BoxGeometry(5, 0.2, 0.5);
      const bladeMaterial = new THREE.MeshPhongMaterial({ color: 0x708090 });

      const blade1 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade1.position.set(2.5, 0, 0);
      rotorGroup.add(blade1);

      const blade2 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade2.position.set(-2.5, 0, 0);
      rotorGroup.add(blade2);

      const blade3 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade3.position.set(0, 0, 2.5);
      blade3.rotation.y = Math.PI / 2;
      rotorGroup.add(blade3);

      const blade4 = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade4.position.set(0, 0, -2.5);
      blade4.rotation.y = Math.PI / 2;
      rotorGroup.add(blade4);

      rotorGroup.position.y = 1;
      helicopter.add(rotorGroup);

      // 尾桨
      const tailRotorGroup = new THREE.Group();
      const tailBladeGeometry = new THREE.BoxGeometry(1, 0.1, 0.2);

      const tailBlade1 = new THREE.Mesh(tailBladeGeometry, bladeMaterial);
      tailBlade1.position.set(0.5, 0, 0);
      tailRotorGroup.add(tailBlade1);

      const tailBlade2 = new THREE.Mesh(tailBladeGeometry, bladeMaterial);
      tailBlade2.position.set(-0.5, 0, 0);
      tailRotorGroup.add(tailBlade2);

      tailRotorGroup.position.set(-4, 0.2, 0);
      helicopter.add(tailRotorGroup);

      // 起落架
      const landingGearGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
      const landingGearMaterial = new THREE.MeshPhongMaterial({ color: 0x696969 });

      const landingGear1 = new THREE.Mesh(landingGearGeometry, landingGearMaterial);
      landingGear1.position.set(0.8, -0.5, 0.8);
      landingGear1.rotation.x = Math.PI / 2;
      helicopter.add(landingGear1);

      const landingGear2 = new THREE.Mesh(landingGearGeometry, landingGearMaterial);
      landingGear2.position.set(-0.8, -0.5, 0.8);
      landingGear2.rotation.x = Math.PI / 2;
      helicopter.add(landingGear2);

      const landingGear3 = new THREE.Mesh(landingGearGeometry, landingGearMaterial);
      landingGear3.position.set(0, -0.5, -1);
      landingGear3.rotation.x = Math.PI / 2;
      helicopter.add(landingGear3);

      helicopter.castShadow = true;

      return {
        group: helicopter,
        rotor: rotorGroup,
        tailRotor: tailRotorGroup
      };
    }

    const helicopter = createHelicopter();
    scene.add(helicopter.group);

    // 设置驾驶舱视角
    function setupCockpitView() {
      // 创建简单的驾驶舱内部
      const cockpit = new THREE.Group();

      // 仪表盘
      const panelGeometry = new THREE.BoxGeometry(3, 1, 0.1);
      const panelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const panel = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.position.set(0, -0.2, -1);
      cockpit.add(panel);

      // 座椅
      const seatGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const seatMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const seat = new THREE.Mesh(seatGeometry, seatMaterial);
      seat.position.set(0, -0.5, 0);
      cockpit.add(seat);

      // 窗户
      const windowGeometry = new THREE.PlaneGeometry(2, 1);
      const windowMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.3
      });
      const window = new THREE.Mesh(windowGeometry, windowMaterial);
      window.position.set(0, 0.2, -0.5);
      cockpit.add(window);

      cockpit.position.set(0, 0, 0.5);
      helicopter.group.add(cockpit);

      // 设置相机位置为驾驶舱视角
      cockpitCamera.position.set(0, 0.5, 0.8);
      cockpitCamera.rotation.y = Math.PI; // 面向正前方
      cockpit.add(cockpitCamera);
    }

    setupCockpitView();

    // 切换视角
    document.getElementById('camera-toggle').addEventListener('click', () => {
      isCockpitView = !isCockpitView;
      currentCamera = isCockpitView ? cockpitCamera : camera;
      document.getElementById('camera-toggle').textContent =
        isCockpitView ? "外部视角" : "驾驶舱视角";
    });

    // 飞行参数
    const flightParams = {
      position: new THREE.Vector3(0, 50, 0),
      velocity: new THREE.Vector3(0, 0, 0),
      rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
      rotorRPM: 0,
      maxRotorRPM: 300,
      collective: 0, // 总距
      cyclic: { pitch: 0, roll: 0 }, // 周期变距
      pedal: 0, // 尾桨踏板
      enginePower: 0,
      maxEnginePower: 1,
      lift: 0,
      drag: 0.98,
      gravity: -0.01
    };

    // 改进的地形生成函数 - 使用多层噪声创建更真实的山脉
    function createMountainTerrain() {
      const terrainSize = 1000;
      const terrainSegments = 128;

      const terrainGeometry = new THREE.PlaneGeometry(
        terrainSize,
        terrainSize,
        terrainSegments,
        terrainSegments
      );

      const vertices = terrainGeometry.attributes.position;

      // 使用多层Perlin噪声生成地形
      for (let i = 0; i < vertices.count; i++) {
        const x = vertices.getX(i);
        const z = vertices.getZ(i);

        // 基础地形高度
        let height = 0;

        // 第一层噪声 - 大尺度山脉
        height += noise(x * 0.002, z * 0.002) * 100;

        // 第二层噪声 - 中等尺度地形特征
        height += noise(x * 0.01, z * 0.01) * 30;

        // 第三层噪声 - 小尺度细节
        height += noise(x * 0.05, z * 0.05) * 10;

        // 添加一些陡峭的山峰
        const distanceToCenter = Math.sqrt(x * x + z * z) / (terrainSize / 2);
        const mountainFactor = 1 - Math.min(distanceToCenter * 1.5, 1);
        height += mountainFactor * noise(x * 0.001, z * 0.001) * 200;

        // 确保边缘高度为0
        height *= (1 - distanceToCenter);

        vertices.setY(i, height);
      }

      terrainGeometry.computeVertexNormals();

      // 创建基于高度的颜色渐变
      const colors = [];
      const color1 = new THREE.Color(0x3a5f0b); // 绿色 - 低海拔
      const color2 = new THREE.Color(0x8B4513); // 棕色 - 中等海拔
      const color3 = new THREE.Color(0x696969); // 灰色 - 高海拔

      for (let i = 0; i < vertices.count; i++) {
        const y = vertices.getY(i);
        let color;

        if (y < 50) {
          color = color1.clone().lerp(color2, y / 50);
        } else {
          color = color2.clone().lerp(color3, (y - 50) / 150);
        }

        colors.push(color.r, color.g, color.b);
      }

      terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const terrainMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,
        wireframe: false,
        flatShading: false
      });

      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrain.rotation.x = -Math.PI / 2;
      terrain.position.y = -5;
      terrain.receiveShadow = true;
      scene.add(terrain);

      return terrain;
    }

    // 简化版Perlin噪声函数
    function noise(x, z) {
      return Math.abs(Math.sin(x * 10.0 + z * 5.0) *
        Math.cos(x * 7.0 - z * 3.0) *
        Math.sin(x * 13.0 + z * 11.0));
    }

    // 添加树木和岩石等细节
    function addTerrainDetails(terrain) {
      const treeGeometry = new THREE.ConeGeometry(2, 5, 8);
      const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2);
      const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });

      const rockGeometry = new THREE.SphereGeometry(1, 6, 6);
      const rockMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });

      // 在随机位置添加树木和岩石
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;

        // 获取地形高度
        const terrainPos = terrain.geometry.attributes.position;
        const closestVertex = findClosestVertex(terrainPos, x, z);
        const y = closestVertex.y;

        if (y > 10 && y < 80) { // 只在中等高度添加植被
          if (Math.random() > 0.3) { // 70%概率是树
            const tree = new THREE.Group();

            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(0, 1, 0);
            trunk.castShadow = true;
            tree.add(trunk);

            const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
            leaves.position.set(0, 4, 0);
            leaves.castShadow = true;
            tree.add(leaves);

            tree.position.set(x, y, z);
            scene.add(tree);
          } else { // 30%概率是岩石
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, y, z);
            rock.castShadow = true;
            scene.add(rock);
          }
        }
      }
    }

    // 辅助函数：找到地形上最近的顶点
    function findClosestVertex(positions, x, z) {
      let closestDist = Infinity;
      let closestY = 0;

      for (let i = 0; i < positions.count; i++) {
        const px = positions.getX(i);
        const pz = positions.getZ(i);
        const dist = Math.sqrt((px - x) ** 2 + (pz - z) ** 2);

        if (dist < closestDist) {
          closestDist = dist;
          closestY = positions.getY(i);
        }
      }

      return { y: closestY };
    }

    // 替换原有的createMountainTerrain函数为更简单的版本
    function createSimpleMountainTerrain() {
      const terrainSize = 1000;
      const terrainSegments = 128;

      const terrainGeometry = new THREE.PlaneGeometry(
        terrainSize, 
        terrainSize, 
        terrainSegments, 
        terrainSegments
      );

      // 简单的正弦波地形
      const vertices = terrainGeometry.attributes.position;
      for (let i = 0; i < vertices.count; i++) {
        const x = vertices.getX(i);
        const z = vertices.getZ(i);
        
        // 基础地形高度 - 使用正弦波创建起伏
        let height = Math.sin(x * 0.01) * 20 + 
                    Math.sin(z * 0.02) * 10 +
                    Math.sin((x + z) * 0.005) * 30;
        
        // 添加中心山峰
        const distToCenter = Math.sqrt(x*x + z*z) / (terrainSize/2);
        height += (1 - distToCenter) * 100;
        
        // 确保边缘平坦
        height *= (1 - distToCenter);
        
        vertices.setY(i, height);
      }

      terrainGeometry.computeVertexNormals();

      // 简单的颜色
      const terrainMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a5f0b,
        wireframe: false,
        flatShading: true
      });

      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrain.rotation.x = -Math.PI / 2;
      terrain.position.y = -5;
      terrain.receiveShadow = true;
      scene.add(terrain);

      return terrain;
    }

    // 替换原有的地形创建
    const terrain = createSimpleMountainTerrain();
    // 可以移除addTerrainDetails调用以简化场景
    addTerrainDetails(terrain);

    // 修改碰撞检测函数以支持地面停靠
    function checkCollision() {
      const aircraftPos = flightParams.position.clone();
      const raycaster = new THREE.Raycaster(
        aircraftPos,
        new THREE.Vector3(0, -1, 0),
        0,
        50 // 增大检测距离
      );

      const intersects = raycaster.intersectObject(terrain);

      if (intersects.length > 0) {
        const groundHeight = intersects[0].point.y;
        const distanceToGround = aircraftPos.y - groundHeight;
        
        // 当接近地面时自动着陆
        if (distanceToGround < 5 && flightParams.velocity.length() < 0.5) {
          flightParams.position.y = groundHeight + 2; // 保持略高于地面
          flightParams.velocity.set(0, 0, 0);
          return false; // 不算作碰撞
        }
        
        // 真正的碰撞检测
        if (distanceToGround < 2) {
          return true;
        }
      }

      return false;
    }

    // 天空盒
    const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
      color: 0x87CEEB,
      side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // 添加雾效增强深度感
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0005);

    // 控制状态
    const controlsState = {
      pitchUp: false,
      pitchDown: false,
      rollLeft: false,
      rollRight: false,
      collectiveUp: false,
      collectiveDown: false,
      pedalLeft: false,
      pedalRight: false,
      engineIncrease: false,
      engineDecrease: false
    };

    // 键盘控制
    document.addEventListener('keydown', (event) => {
      switch (event.key.toLowerCase()) {
        case 's': controlsState.pitchDown = true; break;
        case 'w': controlsState.pitchUp = true; break;
        case 'd': controlsState.rollLeft = true; break;
        case 'a': controlsState.rollRight = true; break;
        case 'arrowup': controlsState.collectiveUp = true; break;
        case 'arrowdown': controlsState.collectiveDown = true; break;
        case 'arrowleft': controlsState.pedalLeft = true; break;
        case 'arrowright': controlsState.pedalRight = true; break;
        case 'q': controlsState.engineIncrease = true; break;
        case 'e': controlsState.engineDecrease = true; break;
        case 'r': // 重置位置
          flightParams.position.set(0, 50, 0);
          flightParams.velocity.set(0, 0, 0);
          flightParams.rotation.set(0, 0, 0);
          flightParams.rotorRPM = 200;
          flightParams.collective = 0.5;
          flightParams.cyclic = { pitch: 0, roll: 0 };
          flightParams.pedal = 0;
          break;
      }
    });

    document.addEventListener('keyup', (event) => {
      switch (event.key.toLowerCase()) {
        case 's': controlsState.pitchDown = false; break;
        case 'w': controlsState.pitchUp = false; break;
        case 'd': controlsState.rollLeft = false; break;
        case 'a': controlsState.rollRight = false; break;
        case 'arrowup': controlsState.collectiveUp = false; break;
        case 'arrowdown': controlsState.collectiveDown = false; break;
        case 'arrowleft': controlsState.pedalLeft = false; break;
        case 'arrowright': controlsState.pedalRight = false; break;
        case 'q': controlsState.engineIncrease = false; break;
        case 'e': controlsState.engineDecrease = false; break;
      }
    });

    // 窗口大小调整
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      cockpitCamera.aspect = window.innerWidth / window.innerHeight;
      cockpitCamera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 游戏循环
    function animate() {
      requestAnimationFrame(animate);

      // 更新引擎功率
      if (controlsState.engineIncrease && flightParams.enginePower < flightParams.maxEnginePower) {
        flightParams.enginePower += 0.005;
      }
      if (controlsState.engineDecrease && flightParams.enginePower > 0) {
        flightParams.enginePower -= 0.005;
      }

      // 更新旋翼转速
      flightParams.rotorRPM = flightParams.enginePower * flightParams.maxRotorRPM;

      // 更新总距(升力控制)
      if (controlsState.collectiveUp && flightParams.collective < 1) {
        flightParams.collective += 0.01;
      }
      if (controlsState.collectiveDown && flightParams.collective > 0) {
        flightParams.collective -= 0.01;
      }

      // 更新周期变距(俯仰和滚转控制)
      if (controlsState.pitchUp) {
        flightParams.cyclic.pitch = Math.min(flightParams.cyclic.pitch + 0.005, 0.1);
      } else if (controlsState.pitchDown) {
        flightParams.cyclic.pitch = Math.max(flightParams.cyclic.pitch - 0.005, -0.1);
      } else {
        // 自动回中
        flightParams.cyclic.pitch *= 0.95;
      }

      if (controlsState.rollLeft) {
        flightParams.cyclic.roll = Math.min(flightParams.cyclic.roll + 0.005, 0.1);
      } else if (controlsState.rollRight) {
        flightParams.cyclic.roll = Math.max(flightParams.cyclic.roll - 0.005, -0.1);
      } else {
        // 自动回中
        flightParams.cyclic.roll *= 0.95;
      }

      // 更新尾桨踏板(偏航控制)
      if (controlsState.pedalLeft) {
        flightParams.pedal = Math.min(flightParams.pedal + 0.01, 0.2);
      } else if (controlsState.pedalRight) {
        flightParams.pedal = Math.max(flightParams.pedal - 0.01, -0.2);
      } else {
        // 自动回中
        flightParams.pedal *= 0.95;
      }

      // 计算升力 (基于旋翼转速和总距)
      flightParams.lift = (flightParams.rotorRPM / flightParams.maxRotorRPM) * flightParams.collective * 0.1;

      // 应用升力和重力
      flightParams.velocity.y += flightParams.lift + flightParams.gravity;

      // 应用阻力
      flightParams.velocity.multiplyScalar(flightParams.drag);

      // 应用周期变距控制
      const forwardForce = flightParams.cyclic.pitch * (flightParams.rotorRPM / flightParams.maxRotorRPM) * 0.1;
      const sideForce = flightParams.cyclic.roll * (flightParams.rotorRPM / flightParams.maxRotorRPM) * 0.1;

      // 创建前进方向向量
      const forwardVector = new THREE.Vector3(0, 0, -1);
      forwardVector.applyEuler(flightParams.rotation);

      // 创建右侧方向向量
      const rightVector = new THREE.Vector3(1, 0, 0);
      rightVector.applyEuler(flightParams.rotation);

      // 应用前进和侧向力
      flightParams.velocity.add(forwardVector.multiplyScalar(forwardForce));
      flightParams.velocity.add(rightVector.multiplyScalar(sideForce));

      // 应用偏航旋转 (尾桨控制)
      flightParams.rotation.y += flightParams.pedal * 0.01 * (flightParams.rotorRPM / flightParams.maxRotorRPM);

      // 根据速度自动倾斜
      if (flightParams.velocity.length() > 0.1) {
        const tiltFactor = 0.005;
        flightParams.rotation.x = THREE.MathUtils.lerp(
          flightParams.rotation.x,
          -flightParams.velocity.z * tiltFactor,
          0.1
        );
        flightParams.rotation.z = THREE.MathUtils.lerp(
          flightParams.rotation.z,
          -flightParams.velocity.x * tiltFactor,
          0.1
        );
      } else {
        // 自动回平
        flightParams.rotation.x *= 0.95;
        flightParams.rotation.z *= 0.95;
      }

      // 更新位置
      flightParams.position.add(flightParams.velocity);

      // 更新直升机模型位置和旋转
      helicopter.group.position.copy(flightParams.position);
      helicopter.group.rotation.copy(flightParams.rotation);

      // 旋转主旋翼和尾桨
      if (flightParams.rotorRPM > 0) {
        helicopter.rotor.rotation.y += flightParams.rotorRPM * 0.01;
        helicopter.tailRotor.rotation.x += flightParams.rotorRPM * 0.03;
      }

      // 更新外部视角相机位置
      camera.position.copy(flightParams.position);
      camera.position.y += 5;
      camera.position.z += 10;
      camera.lookAt(flightParams.position);

      // 更新UI信息
      document.getElementById('altitude').textContent = Math.floor(flightParams.position.y);
      document.getElementById('speed').textContent = Math.floor(flightParams.velocity.length() * 100);
      document.getElementById('vertical-speed').textContent = flightParams.velocity.y.toFixed(1);
      document.getElementById('rotor-rpm').textContent = Math.floor(flightParams.rotorRPM);

      // 碰撞检测
      if (checkCollision()) {
        alert('坠毁了! 按R键重置');
      }

      renderer.render(scene, currentCamera);
    }

    // 初始化飞行参数
    flightParams.rotorRPM = 200;
    flightParams.collective = 0.5;
    flightParams.enginePower = 0.7;

    animate();
  </script>
</body>

</html>