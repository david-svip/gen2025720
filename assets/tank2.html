<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>全屏2D坦克大战</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background-color: #222;
      font-family: Arial, sans-serif;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      background-color: #333;
    }

    #gameInfo {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }

    #instructions {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
      white-space: nowrap;
    }

    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      display: none;
    }

    #gameOver button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #gameOver button:hover {
      background-color: #45a049;
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="gameInfo">
      炮弹: <span id="bulletCount">0</span>/5 |
      积分: <span id="score">0</span> |
      生命: <span id="lives">3</span> |
      自动攻击: <span id="autoFireStatus">关闭</span>
    </div>
    <div id="instructions">
      W/S: 前进/后退 | A/D: 左转/右转 | 空格: 发射炮弹/切换自动攻击 | 鼠标: 瞄准
    </div>
    <div id="gameOver">
      游戏结束!<br>
      <button onclick="resetGame()">重新开始</button>
    </div>
  </div>

  <script>
    // 获取DOM元素
    const gameContainer = document.getElementById('gameContainer');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bulletCountElement = document.getElementById('bulletCount');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');
    const gameOverElement = document.getElementById('gameOver');
    const autoFireStatusElement = document.getElementById('autoFireStatus');

    // 调整画布大小
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // 重置坦克位置到中心
      if (tank) {
        tank.x = canvas.width / 2;
        tank.y = canvas.height / 2;
      }
    }

    // 初始化时和窗口大小变化时调整画布
    window.addEventListener('load', resizeCanvas);
    window.addEventListener('resize', resizeCanvas);
    const initState = {
      lives:14,
    }
    // 游戏状态
    const state = {
      keys: {},
      bullets: [],
      enemies: [],
      explosions: [],
      lastBulletTime: 0,
      lastEnemySpawnTime: 0,
      lastAutoFireTime: 0,
      bulletCooldown:100, // 发射冷却时间(毫秒)
      maxBullets:5000, // 最大炮弹数量
      enemySpawnInterval: 3000, // 敌人生成间隔(毫秒)
      autoFireInterval:200, // 自动攻击间隔(毫秒)
      score: 50000,
      lives:initState.lives,
      gameActive: true,
      autoFire: true,
      spacePressed: false,
      trackColor:'#878787',
      invincibility:false, // 无敌
      showAutoFireTips:false,
    };

    // 玩家坦克对象
    const tank = {
      x: 0, // 将在resizeCanvas中初始化
      y: 0, // 将在resizeCanvas中初始化
      width: 40,
      height: 30,
      color: '#fcb279',
      speed: 2,
      rotation: 0, // 角度(弧度)
      turretRotation: 0, // 炮塔旋转角度
      moving: {
        forward: false,
        backward: false,
        rotateLeft: false,
        rotateRight: false
      },
      // 根据屏幕尺寸设置攻击范围
      attackRange:Math.min(window.innerWidth, window.innerHeight) * .88
    };

    // 敌人类
    class EnemyTank {
      constructor() {
        // 从屏幕边缘随机生成
        const side = Math.floor(Math.random() * 4); // 0:上, 1:右, 2:下, 3:左
        let x, y;

        switch (side) {
          case 0: // 上边
            x = Math.random() * canvas.width;
            y = -30;
            break;
          case 1: // 右边
            x = canvas.width + 30;
            y = Math.random() * canvas.height;
            break;
          case 2: // 下边
            x = Math.random() * canvas.width;
            y = canvas.height + 30;
            break;
          case 3: // 左边
            x = -30;
            y = Math.random() * canvas.height;
            break;
        }

        const colorList = ['#F44336','#cb36f4','#7f36f4','#f43698','#ff9203','#0385ff'];
        const rIndex = Math.floor(Math.random() * colorList.length);
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 30;
        this.color = colorList[rIndex];
        this.speed = 1 + Math.random() * 0.5;
        this.rotation = Math.random() * Math.PI * 2;
        this.turretRotation = 0;
        this.health = 4;
        this.lastShotTime = 0;
        this.shotCooldown = 2000 + Math.random() * 2000;
        this.size = 0; // 用于生成动画
        this.generating = true;
      }

      update() {
        // 生成动画
        if (this.generating) {
          this.size += 0.05;
          if (this.size >= 1) {
            this.size = 1;
            this.generating = false;
          }
          return true;
        }

        // 向玩家移动
        const dx = tank.x - this.x;
        const dy = tank.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 150) { // 如果距离玩家较远，则移动
          this.rotation = Math.atan2(dy, dx);
          this.x += Math.cos(this.rotation) * this.speed;
          this.y += Math.sin(this.rotation) * this.speed;
        }

        // 炮塔瞄准玩家
        this.turretRotation = Math.atan2(dy, dx) - this.rotation;

        // 随机发射炮弹
        if (Date.now() - this.lastShotTime > this.shotCooldown &&
          distance < 400 && Math.random() > 0.95) {
          this.shoot();
        }

        return true;
      }

      shoot() {
        const turretLength = this.width / 2 + 10;
        const bulletX = this.x + Math.cos(this.rotation + this.turretRotation) * turretLength;
        const bulletY = this.y + Math.sin(this.rotation + this.turretRotation) * turretLength;

        state.bullets.push(new Bullet(bulletX, bulletY, this.rotation + this.turretRotation, true));
        this.lastShotTime = Date.now();
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.size, this.size);
        ctx.rotate(this.rotation);

        // 坦克底盘
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

        // 坦克履带
        ctx.fillStyle = state.trackColor;
        ctx.fillRect(-this.width / 2 - 5, -this.height / 2 - 5, this.width + 10, 5);
        ctx.fillRect(-this.width / 2 - 5, this.height / 2, this.width + 10, 5);

        // 炮塔
        ctx.save();
        ctx.rotate(this.turretRotation);
        ctx.fillStyle = '#f2880f';
        ctx.fillRect(0, -5, this.width / 2 + 10, 10);

        // 炮口
        ctx.fillStyle = '#666';
        ctx.fillRect(this.width / 2 + 5, -3, 10, 6);
        ctx.restore();

        ctx.restore();

        // 绘制生命值条
        if (!this.generating) {
          ctx.fillStyle = 'black';
          ctx.fillRect(this.x - 20, this.y - 30, 40, 5);
          ctx.fillStyle = 'red';
          ctx.fillRect(this.x - 20, this.y - 30, 40 * (this.health / 4), 5);
        }
      }

      hit() {
        this.health--;
        if (this.health <= 0) {
          createExplosion(this.x, this.y, 30);
          state.score += 100;
          updateScore();
          return false;
        }
        return true;
      }
    }

    // 炮弹类
    class Bullet {
      constructor(x, y, rotation, isEnemy = false) {
        this.x = x;
        this.y = y;
        this.radius = 5;
        this.speed = isEnemy ? 4 : 7;
        this.dx = Math.cos(rotation) * this.speed;
        this.dy = Math.sin(rotation) * this.speed;
        this.color = isEnemy ? '#FF9800' : '#FF5722';
        this.lifetime = 400; // 炮弹存在时间(帧数)
        this.isEnemy = isEnemy;
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.lifetime--;

        // 边界检测
        if (this.x < 0 || this.x > canvas.width ||
          this.y < 0 || this.y > canvas.height) {
          return false;
        }

        // 碰撞检测
        if (!this.isEnemy) {
          // 玩家炮弹检测敌人碰撞
          for (let i = 0; i < state.enemies.length; i++) {
            const enemy = state.enemies[i];
            if (!enemy.generating && checkCollision(this, enemy)) {
              if (!enemy.hit()) {
                state.enemies.splice(i, 1);
              }
              createExplosion(this.x, this.y, 15);
              return false;
            }
          }
        } else {
          // 敌人炮弹检测玩家碰撞
          if (checkCollision(this, tank)) {
            createExplosion(this.x, this.y, 20);
            state.lives--;
            updateLives();
            if(state.invincibility){
              if(state.lives < 1){
                state.lives = initState.lives;
              }
            }
            if (state.lives <= 0) {
              gameOver();
            }
            return false;
          }
        }

        return this.lifetime > 0;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // 爆炸效果类
    class Explosion {
      constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.particles = [];
        this.duration = 30;

        // 创建爆炸粒子
        for (let i = 0; i < 15; i++) {
          this.particles.push({
            x: 0,
            y: 0,
            radius: 2 + Math.random() * 3,
            color: `hsl(${Math.random() * 30 + 20}, 100%, 50%)`,
            speed: Math.random() * 3 + 2,
            angle: Math.random() * Math.PI * 2,
            life: 30 + Math.random() * 20
          });
        }
      }

      update() {
        this.duration--;
        return this.duration > 0;
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);

        // 绘制爆炸粒子
        for (const p of this.particles) {
          const progress = 1 - (this.duration / 30);
          const distance = p.speed * progress * 10;

          ctx.beginPath();
          ctx.arc(
            Math.cos(p.angle) * distance,
            Math.sin(p.angle) * distance,
            p.radius * (1 - progress * 0.8),
            0,
            Math.PI * 2
          );
          ctx.fillStyle = p.color;
          ctx.globalAlpha = 1 - progress;
          ctx.fill();
          ctx.closePath();
        }

        ctx.restore();
      }
    }

    // 碰撞检测
    function checkCollision(bullet, tank) {
      // 简化碰撞检测，使用圆形和矩形检测
      const tankLeft = tank.x - tank.width / 2;
      const tankRight = tank.x + tank.width / 2;
      const tankTop = tank.y - tank.height / 2;
      const tankBottom = tank.y + tank.height / 2;

      // 找到矩形上距离圆心最近的点
      const closestX = Math.max(tankLeft, Math.min(bullet.x, tankRight));
      const closestY = Math.max(tankTop, Math.min(bullet.y, tankBottom));

      // 计算距离
      const distanceX = bullet.x - closestX;
      const distanceY = bullet.y - closestY;
      const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

      return distance < bullet.radius;
    }

    // 创建爆炸效果
    function createExplosion(x, y, size) {
      state.explosions.push(new Explosion(x, y, size));
    }

    // 自动攻击范围内的敌人
    function autoFireAtEnemies() {
      if (!state.autoFire || !state.gameActive) return;

      // 检查冷却时间
      if (Date.now() - state.lastAutoFireTime < state.autoFireInterval) return;

      // 检查炮弹数量
      if (state.bullets.length >= state.maxBullets) return;

      // 寻找最近的敌人
      let closestEnemy = null;
      let minDistance = Infinity;

      for (const enemy of state.enemies) {
        if (enemy.generating) continue;

        const dx = enemy.x - tank.x;
        const dy = enemy.y - tank.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < tank.attackRange && distance < minDistance) {
          closestEnemy = enemy;
          minDistance = distance;
        }
      }

      // 如果有敌人在攻击范围内，自动瞄准并射击
      if (closestEnemy) {
        // 计算敌人方向
        const dx = closestEnemy.x - tank.x;
        const dy = closestEnemy.y - tank.y;
        tank.turretRotation = Math.atan2(dy, dx) - tank.rotation;

        // 发射炮弹
        fireBullet();
        state.lastAutoFireTime = Date.now();
      }
    }

    // 更新UI
    function updateBulletCount() {
      bulletCountElement.textContent = `${state.bullets.length}/${state.maxBullets}`;
    }

    function updateScore() {
      scoreElement.textContent = state.score;
    }

    function updateLives() {
      livesElement.textContent = state.lives;
    }

    function updateAutoFireStatus() {
      autoFireStatusElement.textContent = state.autoFire ? "开启" : "关闭";
      autoFireStatusElement.style.color = state.autoFire ? "#4CAF50" : "#F44336";
    }

    // 游戏结束
    function gameOver() {
      state.gameActive = false;
      gameOverElement.style.display = 'block';
      createExplosion(tank.x, tank.y, 40);
    }

    // 重置游戏
    function resetGame() {
      state.bullets = [];
      state.enemies = [];
      state.explosions = [];
      state.score = 0;
      state.lives = initState.lives;
      state.gameActive = true;
      state.autoFire = false;

      tank.x = canvas.width / 2;
      tank.y = canvas.height / 2;
      tank.rotation = 0;
      tank.attackRange = Math.min(canvas.width, canvas.height) * 0.4;

      updateBulletCount();
      updateScore();
      updateLives();
      updateAutoFireStatus();
      gameOverElement.style.display = 'none';
    }

    // 键盘事件监听
    window.addEventListener('keydown', (e) => {
      state.keys[e.key.toLowerCase()] = true;
      updateTankMovement();
    });

    window.addEventListener('keyup', (e) => {
      state.keys[e.key.toLowerCase()] = false;
      updateTankMovement();
    });

    function updateTankMovement() {
      if (!state.gameActive) return;

      tank.moving = {
        forward: state.keys['w'],
        backward: state.keys['s'],
        rotateLeft: state.keys['a'],
        rotateRight: state.keys['d']
      };

      // 空格键切换自动攻击模式
      if (state.keys[' ']) {
        if (!state.spacePressed) { // 防止按住空格键时重复切换
          state.autoFire = !state.autoFire;
          updateAutoFireStatus();
          state.spacePressed = true;
        }
      } else {
        state.spacePressed = false;
      }
    }

    function fireBullet() {
      // 计算炮口位置
      const turretLength = tank.width / 2 + 10;
      const bulletX = tank.x + Math.cos(tank.rotation + tank.turretRotation) * turretLength;
      const bulletY = tank.y + Math.sin(tank.rotation + tank.turretRotation) * turretLength;

      state.bullets.push(new Bullet(bulletX, bulletY, tank.rotation + tank.turretRotation));
      state.lastBulletTime = Date.now();
      updateBulletCount();
    }

    // 生成敌人
    function spawnEnemy() {
      if (state.gameActive && Date.now() - state.lastEnemySpawnTime > state.enemySpawnInterval) {
        state.enemies.push(new EnemyTank());
        state.lastEnemySpawnTime = Date.now();

        // 随着分数增加，敌人生成速度加快
        state.enemySpawnInterval = Math.max(1000, 3000 - state.score / 10);
      }
    }

    // 绘制玩家坦克
    function drawTank() {
      ctx.save();
      ctx.translate(tank.x, tank.y);
      ctx.rotate(tank.rotation);
      // 坦克底盘
      ctx.fillStyle = tank.color;
      ctx.fillRect(-tank.width / 2, -tank.height / 2, tank.width, tank.height);
      // 坦克前方标识 - 绘制在坦克主体前部
      ctx.fillStyle = state.trackColor;
      ctx.beginPath();
      ctx.moveTo(tank.width / 2 - 5, -tank.height / 2 + 5);
      ctx.lineTo(tank.width / 2, -tank.height / 2 + 15);
      ctx.lineTo(tank.width / 2 - 10, -tank.height / 2 + 15);
      ctx.closePath();
      ctx.fill();
      //
      ctx.beginPath();
      ctx.moveTo(tank.width / 2 - 5, tank.height / 2 - 5);
      ctx.lineTo(tank.width / 2, tank.height / 2 - 15);
      ctx.lineTo(tank.width / 2 - 10, tank.height / 2 - 15);
      ctx.closePath();
      ctx.fill();

      // 坦克履带
      ctx.fillStyle = state.trackColor;
      ctx.fillRect(-tank.width / 2 - 5, -tank.height / 2 - 5, tank.width + 10, 5);
      ctx.fillRect(-tank.width / 2 - 5, tank.height / 2, tank.width + 10, 5);

      // 炮塔
      ctx.save();
      ctx.rotate(tank.turretRotation);
      ctx.fillStyle = '#e69b63';
      ctx.fillRect(0, -5, tank.width / 2 + 10, 10);

      // 炮口
      ctx.fillStyle = '#666';
      ctx.fillRect(tank.width / 2 + 5, -3, 10, 6);
      ctx.restore();

      ctx.restore();

      // 绘制攻击范围指示器(当自动攻击开启时)
      if (state.autoFire && state.showAutoFireTips) {
        ctx.beginPath();
        ctx.arc(tank.x, tank.y, tank.attackRange, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(76, 175, 80, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();
      }
    }

    // 更新游戏状态
    function update() {
      if (!state.gameActive) return;

      // 生成敌人
      spawnEnemy();

      // 玩家坦克移动
      if (tank.moving.forward) {
        tank.x += Math.cos(tank.rotation) * tank.speed;
        tank.y += Math.sin(tank.rotation) * tank.speed;
      }
      if (tank.moving.backward) {
        tank.x -= Math.cos(tank.rotation) * tank.speed;
        tank.y -= Math.sin(tank.rotation) * tank.speed;
      }
      if (tank.moving.rotateLeft) {
        tank.rotation -= 0.05;
      }
      if (tank.moving.rotateRight) {
        tank.rotation += 0.05;
      }

      // 如果没有自动攻击，炮塔跟随鼠标
      if (!state.autoFire) {
        const mouseX = state.mouseX || canvas.width / 2;
        const mouseY = state.mouseY || canvas.height / 2;
        const dx = mouseX - tank.x;
        const dy = mouseY - tank.y;
        tank.turretRotation = Math.atan2(dy, dx) - tank.rotation;
      }

      // 自动攻击
      autoFireAtEnemies();

      // 边界检查
      tank.x = Math.max(tank.width / 2, Math.min(canvas.width - tank.width / 2, tank.x));
      tank.y = Math.max(tank.height / 2, Math.min(canvas.height - tank.height / 2, tank.y));

      // 更新敌人
      for (let i = 0; i < state.enemies.length; i++) {
        if (!state.enemies[i].update()) {
          state.enemies.splice(i, 1);
          i--;
        }
      }

      // 更新炮弹
      state.bullets = state.bullets.filter(bullet => bullet.update());

      // 更新爆炸效果
      state.explosions = state.explosions.filter(explosion => explosion.update());

      updateBulletCount();
    }

    // 绘制游戏
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 绘制炮弹
      state.bullets.forEach(bullet => bullet.draw(ctx));

      // 绘制敌人
      state.enemies.forEach(enemy => enemy.draw(ctx));

      // 绘制爆炸效果
      state.explosions.forEach(explosion => explosion.draw(ctx));

      // 绘制玩家坦克
      if (state.gameActive) {
        drawTank();
        drawTank();
      }
    }

    // 鼠标移动事件
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      state.mouseX = e.clientX - rect.left;
      state.mouseY = e.clientY - rect.top;
    });

    // 游戏循环
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // 开始游戏
    window.resetGame = resetGame; // 使重置函数全局可用
    resizeCanvas(); // 初始化画布大小
    updateBulletCount();
    updateScore();
    updateLives();
    updateAutoFireStatus();
    gameLoop();
  </script>
</body>

</html>